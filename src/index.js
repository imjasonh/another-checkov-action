const core = require('@actions/core');
const exec = require('@actions/exec');
const github = require('@actions/github');
const fs = require('fs');
const path = require('path');
const { parseCheckovResults } = require('./parser');
const { generateSummary } = require('./summary');
const { addAnnotations } = require('./annotations');

async function run() {
  try {
    // Get inputs
    const failOnError = core.getInput('fail-on-error') !== 'false';
    const checkovVersion = core.getInput('checkov-version') || 'latest';
    const checkovFlags = core.getInput('checkov-flags') || '';

    core.info('Installing Checkov...');
    await installCheckov(checkovVersion);

    core.info('Running Checkov scan...');
    const outputFile = path.join(process.env.RUNNER_TEMP || '/tmp', 'checkov-results.json');

    const exitCode = await runCheckov(outputFile, checkovFlags);

    // Read and parse results
    let results = null;
    if (fs.existsSync(outputFile)) {
      const rawResults = fs.readFileSync(outputFile, 'utf8');
      results = parseCheckovResults(rawResults);

      // Set output
      core.setOutput('results', rawResults);
    } else {
      core.warning('No results file generated by Checkov');
    }

    if (results) {
      // Generate summary
      await generateSummary(results, github.context);

      // Add annotations for PR context
      if (github.context.eventName === 'pull_request') {
        await addAnnotations(results, github.context);
      }

      // Handle failure based on results (not exit code, since we use --soft-fail)
      if (results.summary.failed > 0 && failOnError) {
        core.setFailed(`Checkov found ${results.summary.failed} security issue${results.summary.failed > 1 ? 's' : ''}`);
      } else if (results.summary.failed > 0) {
        core.warning(`Checkov found ${results.summary.failed} security issue${results.summary.failed > 1 ? 's' : ''} but fail-on-error is disabled`);
      } else {
        core.info('Checkov scan completed successfully with no issues');
      }
    } else if (exitCode !== 0) {
      // Fallback if we couldn't parse results
      if (failOnError) {
        core.setFailed(`Checkov exited with code ${exitCode}`);
      } else {
        core.warning(`Checkov exited with code ${exitCode} but fail-on-error is disabled`);
      }
    }

  } catch (error) {
    core.setFailed(`Action failed: ${error.message}`);
  }
}

async function installCheckov(version) {
  const pipCommand = version === 'latest'
    ? ['pip3', 'install', '--no-cache-dir', 'checkov']
    : ['pip3', 'install', '--no-cache-dir', `checkov==${version}`];

  await exec.exec(pipCommand[0], pipCommand.slice(1));
}

async function runCheckov(outputFile, checkovFlags) {
  let userFlags = [];

  // Parse user flags if provided
  if (checkovFlags) {
    userFlags = checkovFlags.trim().split(/\s+/).filter(f => f);

    // Check if user specified --output and warn/remove it
    const outputIndex = userFlags.findIndex(f => f === '--output' || f === '-o');
    if (outputIndex !== -1) {
      core.warning('Overriding --output flag (must be JSON for parsing)');
      userFlags.splice(outputIndex, 2); // Remove --output and its value
    }

    // Check if user specified --soft-fail and remove it (we manage this)
    const softFailIndex = userFlags.findIndex(f => f === '--soft-fail');
    if (softFailIndex !== -1) {
      core.info('Removing redundant --soft-fail flag (already set by action)');
      userFlags.splice(softFailIndex, 1);
    }

    if (userFlags.length > 0) {
      core.info(`Using checkov flags: ${userFlags.join(' ')}`);
    }
  }

  // Add --directory . if not already specified
  const hasDirectory = userFlags.some(f => f.startsWith('--directory') || f === '-d');
  const hasFile = userFlags.some(f => f.startsWith('--file') || f === '-f');

  const args = [
    '--output', 'json',
    '--soft-fail',  // Always use soft-fail to capture results; we'll handle failure in the action
  ];

  // Default to current directory if neither --directory nor --file specified
  if (!hasDirectory && !hasFile) {
    args.push('--directory', '.');
  }

  args.push(...userFlags);

  let exitCode = 0;
  let outputData = '';

  try {
    exitCode = await exec.exec('checkov', args, {
      ignoreReturnCode: true,
      listeners: {
        stdout: (data) => {
          const text = data.toString();
          outputData += text;
          core.debug(text);
        },
        stderr: (data) => {
          core.debug(data.toString());
        }
      }
    });
  } catch (error) {
    // Checkov returns non-zero when findings are present
    exitCode = error.exitCode || 1;
  }

  // Write captured output to file
  if (outputData) {
    fs.writeFileSync(outputFile, outputData);
  }

  return exitCode;
}

run();
