const core = require('@actions/core');
const exec = require('@actions/exec');
const github = require('@actions/github');
const fs = require('fs');
const path = require('path');
const { parseCheckovResults } = require('./parser');
const { generateSummary } = require('./summary');
const { addAnnotations } = require('./annotations');

async function run() {
  try {
    // Get inputs
    const directory = core.getInput('directory') || '.';
    const framework = core.getInput('framework') || 'all';
    const softFail = core.getInput('soft-fail') === 'true';
    const checkovVersion = core.getInput('checkov-version') || 'latest';
    let configFile = core.getInput('config-file') || '';

    // Check for default config file if not specified
    if (!configFile) {
      const defaultConfigs = ['.checkov.yaml', '.checkov.yml'];
      for (const defaultConfig of defaultConfigs) {
        if (fs.existsSync(defaultConfig)) {
          configFile = defaultConfig;
          core.info(`Using config file: ${configFile}`);
          break;
        }
      }
    }

    core.info('Installing Checkov...');
    await installCheckov(checkovVersion);

    core.info(`Running Checkov scan on directory: ${directory}`);
    const outputFile = path.join(process.env.RUNNER_TEMP || '/tmp', 'checkov-results.json');

    const exitCode = await runCheckov(directory, framework, outputFile, configFile);

    // Read and parse results
    let results = null;
    if (fs.existsSync(outputFile)) {
      const rawResults = fs.readFileSync(outputFile, 'utf8');
      results = parseCheckovResults(rawResults);

      // Set output
      core.setOutput('results', rawResults);
    } else {
      core.warning('No results file generated by Checkov');
    }

    if (results) {
      // Generate summary
      await generateSummary(results, github.context);

      // Add annotations for PR context
      if (github.context.eventName === 'pull_request') {
        await addAnnotations(results, github.context);
      }
    }

    // Handle failure
    if (exitCode !== 0 && !softFail) {
      core.setFailed(`Checkov found security issues (exit code: ${exitCode})`);
    } else if (exitCode !== 0) {
      core.warning(`Checkov found security issues but soft-fail is enabled`);
    } else {
      core.info('Checkov scan completed successfully with no issues');
    }

  } catch (error) {
    core.setFailed(`Action failed: ${error.message}`);
  }
}

async function installCheckov(version) {
  const pipCommand = version === 'latest'
    ? ['pip3', 'install', '--no-cache-dir', 'checkov']
    : ['pip3', 'install', '--no-cache-dir', `checkov==${version}`];

  await exec.exec(pipCommand[0], pipCommand.slice(1));
}

async function runCheckov(directory, framework, outputFile, configFile) {
  const args = [
    '--directory', directory,
    '--output', 'json',
    '--soft-fail'  // Always use soft-fail to capture results; we'll handle failure in the action
  ];

  if (framework !== 'all') {
    args.push('--framework', framework);
  }

  if (configFile) {
    args.push('--config-file', configFile);
  }

  let exitCode = 0;
  let outputData = '';

  try {
    exitCode = await exec.exec('checkov', args, {
      ignoreReturnCode: true,
      listeners: {
        stdout: (data) => {
          const text = data.toString();
          outputData += text;
          core.debug(text);
        },
        stderr: (data) => {
          core.debug(data.toString());
        }
      }
    });
  } catch (error) {
    // Checkov returns non-zero when findings are present
    exitCode = error.exitCode || 1;
  }

  // Write captured output to file
  if (outputData) {
    fs.writeFileSync(outputFile, outputData);
  }

  return exitCode;
}

run();
